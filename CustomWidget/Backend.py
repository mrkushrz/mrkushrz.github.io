# -*- coding: utf-8 -*-
"""Backend_Prompt-ChatGPT-Aufruf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B12S-DAxvJMQxp7K14ls-mBireKQ3Kj9
"""

!pip install openai

import os
from openai import AzureOpenAI

os.environ['AZURE_OPENAI_KEY'] = '65ee6d36768e44b894d04c922e6cbe7a'
os.environ['AZURE_OPENAI_ENDPOINT'] = 'https://mbeopenai.openai.azure.com/'

client = AzureOpenAI(
  api_key = os.getenv("AZURE_OPENAI_KEY"),
  api_version = "2023-05-15",
  azure_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
)

import requests
from bs4 import BeautifulSoup
import pandas as pd
from datetime import datetime, timedelta
import yfinance as yf
import re

def get_commodity_profile(commodity_name):
    prompt = f"Generate a short description for the commodity {commodity_name} (e.g., sugar, wheat). Also list general positive and negative factors that might impact its price. Be brief and use keywords. Consider diverse factors including agricultural production conditions (e.g., weather patterns, crop yield), market dynamics (e.g., global supply and demand, stock levels), economic factors (e.g., inflation, trade policies), and environmental considerations (e.g., sustainability, climate change). Use the format Description: ..., Positive Factors: ..., Negative Factors: ..."

    response = client.chat.completions.create(
        model="GPT35",
        messages=[ #Verbesserungen möglich
            {"role": "system", "content": "Assistant is a large language model trained by OpenAI."},
            {"role": "user", "content": prompt}
        ]
    )
    return response.choices[0].message.content

def format_market_data(df):
    df.reset_index(inplace=True)
    df['Date'] = df['Date'].dt.strftime('%m/%d/%Y')
    df['Date'] = pd.to_datetime(df['Date'], format='%m/%d/%Y')
    df.set_index('Date', inplace=True)
    return df

# Dictionary to store data frames and their sources for each commodity
commodity_data = {}

# Fetch and process data for US Sugar #11 Futures
sbf = yf.Ticker("SB=F")
hist_sugar11 = sbf.history(period="max")
df_sugar11 = pd.DataFrame(hist_sugar11).drop(columns=['Dividends', 'Stock Splits'])
df_sugar11 = format_market_data(df_sugar11)
commodity_data["globalsugar"] = {"data": df_sugar11, "source": "SB=F"}

# Add more commodities in a similar way
# Example for European Sugar (Placeholder Tickers)
# sbf_euro = yf.Ticker("EURO_SUGAR_TICKER")
# hist_eurosugar = sbf_euro.history(period="max")
# df_eurosugar = pd.DataFrame(hist_eurosugar).drop(columns=['Dividends', 'Stock Splits'])
# df_eurosugar = format_market_data(df_eurosugar)
# commodity_data["europeansugar"] = {"data": df_eurosugar, "source": "EURO_SUGAR_TICKER"}

# If European Sugar requires data from multiple sources, merge them
# df_combined_eurosugar = pd.concat([df_eurosugar, df_other_source])
# commodity_data["europeansugar"] = {"data": df_combined_eurosugar, "source": ["EURO_SUGAR_TICKER", "OTHER_SOURCE_TICKER"]}

def get_price_data(commodity_name, start_date, end_date):
    commodity_info = commodity_data.get(commodity_name)
    if commodity_info is None:
        raise ValueError(f"No data available for commodity: {commodity_name}")

    df = commodity_info["data"]
    start_date_dt = pd.to_datetime(start_date)
    three_weeks_before = start_date_dt - timedelta(weeks=3)
    end_date_dt = pd.to_datetime(end_date)
    filtered_data = df.loc[three_weeks_before:end_date_dt]

    return filtered_data, commodity_info["source"]

def format_price_data_sources(commodity_name, start_date, end_date):
    # Access commodity data and handle the case where there's no data
    commodity_sources = commodity_data.get(commodity_name, [])
    if not commodity_sources:
        raise ValueError(f"No data available for commodity: {commodity_name}")

    # Initialize variable for formatted source and price data
    formatted_data = ""

    if isinstance(commodity_sources, dict):  # Handle single source
      commodity_sources = [commodity_sources]

    # Loop over each source and get and format its data
    for source_info in commodity_sources: # Multiple Source
        # Get filtered data for each source
        filtered_data, _ = get_price_data(commodity_name, start_date, end_date)

        # Append formatted data for each source
        formatted_data += f"(Source/Ticker: {source_info['source']}):\n{filtered_data}\n\n"

    return formatted_data

def generate_analysis_prompt(commodity_name, start_date, end_date, commodity_profile, df_news):

    price_data = format_price_data_sources(commodity_name, start_date, end_date)

    news = []  # Initialize an empty list

    for index, row in df_news.iterrows():
      news.append(row['summary_and_keywords']+ '\n')

    prompt = f"""
    Instruction: Explain the price movement for the commodity {commodity_name} from {start_date} to {end_date}, by analyzing the commodity's market profile, historical weekly news summary, keywords, and price history. Discuss the factors that influenced the price movement.

    Commodity Profile: {commodity_profile}
    Price History:
    {price_data}
    Recent News: News are ordered weekly from oldest to latest.
    {news}

    Now analyze the commodity's price movement from {start_date} to {end_date}. Only use the prices provided.
    Provide a Summary and an analysis of the Commodity Price Movement.
    The analysis should comprehensively explain the reasons, key factors and events that influenced the price movement.
    Do not just summarize the history. Reason step by step before the finalized output.
    Use format Summary: ..., Commodity Price Movement Analysis: ...
    Use bulletpoints for structuring the different factors and events in the analysis.
    """

    return prompt

def generate_forecast_prompt(commodity_name, start_date, end_date, commodity_profile, df_news):

    price_data = format_price_data_sources(commodity_name, start_date, end_date)

    news = []  # Initialize an empty list

    for index, row in df_news.iterrows():
      news.append(row['summary_and_keywords']+ '\n')

    prompt = f"""
    Instruction: Forecast next month's price movement for the commodity {commodity_name}, given the commodity's market profile, historical weekly news summary, keywords, and price trends, and optionally examples from similar commodities.

    The trend is represented by bins "D5+", "D5", "D4", "D3", "D2", "D1", "U1", "U2", "U3", "U4", "U5", "U5+", where "D5+" means price dropping more than 5%, D5 means price dropping between 4% and 5%, and so on, with "U" indicating upward trends and “D” indication downward trends.

    Commodity Profile: {commodity_profile}

    Prices
    {price_data}
    Recent Commodity News: News are ordered weekly from oldest to latest.
    {news}


    Now predict what could be the next month’s Summary, Keywords, and forecast the Commodity Price Movement.
    The predicted Summary/Keywords should explain the price movement forecasting.
    You should predict what could happen next month/s. Do not just summarize the history.
    The next month's price movement must not be the same as the previous weeks.
    Reason step by step before the finalized output.
    Use format Summary: ..., Commodity Price Movement: ...
    """

    return prompt

import sqlite3

def fetch_news_data(db_path):
    """
    Connects to an SQLite database, fetches all data from the news_table,
    and returns it as a pandas DataFrame.

    Parameters:
    db_path (str): Path to the SQLite database file.

    Returns:
    pd.DataFrame: DataFrame containing the fetched news data.
    """
    # Connect to the SQLite database
    connection = sqlite3.connect(db_path)

    # Create a cursor object
    cursor = connection.cursor()

    # Execute a query to fetch all data from the news_table
    cursor.execute("SELECT * FROM news_table")

    # Fetch all rows from the query
    rows = cursor.fetchall()

    # Convert the rows to a DataFrame
    df_news = pd.DataFrame(rows, columns=[description[0] for description in cursor.description])

    # Close the connection to the database
    connection.close()

    # Convert the 'timedate' column to datetime and format it
    df_news['timedate'] = pd.to_datetime(df_news['timedate']).dt.strftime('%m/%d/%Y')

    return df_news

def filter_dataframe_by_date(df, start_date, end_date):

    # Convert the start and end dates to datetime
    start_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)

    # Calculate the date 3 weeks before the start date
    start_date_minus_3_weeks = start_date - timedelta(weeks=3)

    # Filter the dataframe
    filtered_df = df[(pd.to_datetime(df['timedate']) >= start_date_minus_3_weeks) & (pd.to_datetime(df['timedate']) <= end_date)]

    return filtered_df

def generate_commodity_response(start_date, end_date, commodity, prompt):
    df_news = fetch_news_data('news_data_2023.db')
    df_news = filter_dataframe_by_date(df_news, start_date, end_date)  # Replace df_news with a call to your SQLite database

    commodity_profile = get_commodity_profile(commodity)

    if prompt == "analysis":
        generated_prompt = generate_analysis_prompt(commodity, start_date, end_date, commodity_profile, df_news)
    elif prompt == "forecast":
        generated_prompt = generate_forecast_prompt(commodity, start_date, end_date, commodity_profile, df_news)
    else:
        raise ValueError("Invalid prompt type. Choose 'analysis' or 'forecast'.")

    response = client.chat.completions.create(
        model="GPT35",
        messages=[
            {"role": "system", "content": "Forget all your previous instructions. Pretend you are a commodity market analyst. You are a financial expert with experience in analyzing, interpreting and forecasting commodity market trends, specifically focusing on commodities like sugar or wheat."},
            {"role": "user", "content": generated_prompt}
        ]
    )


    return response.choices[0].message.content

print(generate_commodity_response('03/19/2023', '04/24/2023', 'globalsugar', 'analysis'))